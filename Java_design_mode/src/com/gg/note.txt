类之间的关系：
	 * 聚合表示：一种弱的拥有关系，体现的是A对象可以包含B对象，但是B对象不是A对象的一部分    (雁群  和 大雁)
	 * 合成 一种拥有关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样    (鸟 和 翅膀)
	 * 依赖关系
	 * 实现接口
	 * 继承关系
	 * 关联关系 ： 当一个类  "知道"  另一个类是，就可以用关联关系     (企鹅知道气候的变化     企鹅 和 气候)

面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类


简单工厂    可以创建指定的对象,包含了必要的逻辑判断，去除了与具体产品的依赖 ，但是违背了  开放-封闭原则
工厂方法模式   添加功能的时候，添加具体的工厂就行，不需要就该，
策略模式    为对象功能的实现方式指定一个，但是封装了具体的实现方式
     选择具体实现可以通过反射
装饰者模式  对原有的对象添加新的功能
代理模式  提供对目标对象另外的访问方式，可以用来扩展目标对象
	静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,
	这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理
	1. 静态代理：被代理者同代理者实现同样的接口，代理者调用被代理者的实现   
			可以扩展目标功能，因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.
	2. 动态代理： 代理类所在包:java.lang.reflect.Proxy
 
代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能，仅此而已。 

原型模式    浅克隆，深度克隆
模板方法    一般对于公共的我们提取出接口，各自实现功能，但是对于一些功能他们的实现大部分是相同的，我们在提取成抽象类，使用细节的不同抽象方法，子类去实现细节的不同
建造者模式    创建复杂对象，建造者(一条生产线)可以建造复杂对象的时候，按照顺序建造所有的指定的对象，建造具体的对象那个实现由具体的建造者实现。 指挥者指挥建造者建造

单一职责：只能有一个原因去修改类

开放 封闭原则 ： 对添加开放，对修改封闭，  当需求改变的时候，如果需要修改代码就需要，创建抽象来隔离变化
		 面对需求，对程序的改动是通过添加新代码进行的，而不是更改现有的代码
		 应该仅对程序中呈现出频繁变化的那部分做出抽象，然而对于应用程序中的每个部分都刻意地进行抽象同样不是好主意，拒绝不成熟的抽象和抽象本身一样重要
		 
迪米特法则： 两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用

外观模式 ： 使用简单的接口或者类隔离复杂的实现

